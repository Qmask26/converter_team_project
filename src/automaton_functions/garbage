-- Utilits
local stack = {}
function stack.push(item)
    table.insert(stack, item) 
end
function stack.pop()
    return table.remove(stack)
end

local function contains(tb, arg)
    for i = 1, #tb, 1 do 
        if tb[i] == arg then return true end
    end
    return false
end

local function nestedContains(tb, arg)
    local found = false
    local l = #tb
    if #arg == 0 then return true end
    for i = 1, l, 1 do
        if #arg ~= #tb[i] then goto continue end
        for j = 1, #tb[i], 1 do
            found = (tb[i][j] == arg[j])
            if found ~= true then break end
        end
        if found then return found end
        ::continue:: 
    end
    return found
end

local function getAlphabet(transitions)
    local alph = {}
    for i = 1, #transitions, 1 do
        if contains(alph, transitions[i].symbol) == false then 
            table.insert(alph, #alph + 1, transitions[i].symbol)
        end
    end
    return alph
end

local function mergeTables(tb1, tb2)
    for i = 1, #tb2, 1 do
        table.insert(tb1, #tb1 + 1, tb2[i])
    end
    return tb1
end

local tr ={}
function tr.inittr(from_in, to_in, symbol_in)
    table.insert(tr, {from = from_in, to = to_in, symbol = symbol_in})
end

function tr.getTransition(from, symbol)
    for i = 1, #tr, 1 do
        if tr[i].from == from and tr[i].symbol == symbol then return tr[i].to end
    end
end

-- Main functions
local function dfs(nfa, state_ind, eStates, trans)
    local included = nestedContains(eStates, state_ind)

    if included == false then
        table.insert(eStates, #eStates + 1, state_ind)

        local allT = tr.getTransition(state_ind, '')
        for i = 1, #allT, 1 do
            dfs(nfa, allT[i], eStates)
        end 
    end
end

local function closure(nfa, states)
    local eStates = {}
    for i = 1, #states, 1 do
        table.insert(eStates, #eStates + 1, states[i]) 
    end
    for i = 1, #states, 1 do
        dfs(nfa, states[i], eStates)
    end
    return eStates
end 

function Det(nfa)
    for i = 1, #nfa.transitions_raw, 1 do
        tr.inittr({nfa.transitions_raw[i].from}, {nfa.transitions_raw.to}, nfa.transitions_raw[i].symbol)
    end
    if nfa.isDFA then return end

    local q0 = closure(nfa, {{1}})
    
    local Q = {q0}
    local F = {}
    local alph = getAlphabet(nfa.transitions_raw)
    stack.push({1})

    while #stack ~= 0 do
       local z = stack.pop()
       if nfa:isStateFinal(z[i]) then table.insert(F, #F + 1, z[i]) break end

       for i = 1, #alph, 1 do
            local transitions = {}
            for j = 1, #z, 1 do
                local check = tr.getTransition(z[j], alph[i])
                if check ~= nil then 
                    transitions = mergeTables(transitions, check)
                end
            end
            local z1 = closure(nfa, transitions)
            
            if nestedContains(Q, z1) == false then
                table.insert(Q, #Q + 1, z1)
                stack.push(z1)
            end

            tr.inittr(z, z1, alph[i])
       end
    end

    for i = 1, #Q, 1 do
        print("\nnum", i)
        for j = 1, #Q[i], 1 do
            for k = 1, #Q[i][j], 1 do
                io.write(Q[i][j][k], " ")
            end 
            io.write("-")
        end 
    end
    print()

    print("alph")
    for i = 1, #alph, 1 do
        io.write(alph[i] .. " ")
    end
    print()

    print("trans")
    for i = 1, #tr, 1 do
        for j = 1, #tr[i].from, 1 do
            io.write(tr[i].from[j], " ")
        end
        io.write(tr[i].symbol, "-> ")

        if tr.to ~= nil then 
            for j = 1, #tr.to, 1 do
                for k = 1, #tr.to[j], 1 do
                    io.write(tr.to[j][k], " ")
                end
            end
        end
        print()
    end
    print()

    print("fin")
    for i = 1, #F, 1 do
        io.write(F[i], " ")
    end
    print()

    io.write("start: {")
    for i = 1, #q0, 1 do
        io.write(q0[i] .. " ")
    end
    print("}")
end